# Creating threads in Python - (a) Using Function
import threading

def greet():
    print("Hello from thread ")

t = threading.Thread(target=greet)
t.start()
t.join()

# Creating threads in Python - (a) Using Class

class Mythread(threading.Thread):
    def run(self):
        print("Thread is running ! ")

t1 = Mythread()
t1.start()
t1.join()

#Single Tasking and Multitasking - (a) Single Tasking (one task at a time)
import threading

def task():
    for i in range(3):
        print("Task running : ", i)

t = threading.Thread(target=task)
t.start()
t.join()

# Single Tasking and Multitasking - (b) Multitasking (using multiple threads)
def numbers():
    for i in range(1, 6):
        print("Number : ", i)

def letters():
    for ch in ['A', 'B', 'C', 'D', 'E']:
        print("Letter : ", ch)

t1 = threading.Thread(target=numbers)
t1.start()
t1.join()

t2 = threading.Thread(target=letters)
t2.start()
t2.join()

# Thread Synchronization (Using Lock)
import threading

counter = 0
lock = threading.Lock()

def increment():
    global counter
    for _ in range(10000):
        with lock:
            counter += 1

t1 = threading.Thread(target=increment)
t2 = threading.Thread(target=increment)

t1.start()
t2.start()

t1.join()
t2.join()

print("Final Counter value : ", counter)

# Avoiding Deadlock (using lock order)

import threading
import time

lock1 = threading.Lock()
lock2 = threading.Lock()

def task1():
    with lock1:
        print("Task 1 acquired lock1 \n")
        time.sleep(1)
        if lock2.acquire(timeout=2):
            print("Task 1 acquired lock2 \n")
            lock2.release()
        else:
            print("Task 1 could not acquire lock2  \n")

def task2():
    with lock2:
        print("Task 2 acquired lock2  \n")
        time.sleep(1)
        if lock1.acquire(timeout=2):
            print("Task 2 acquired lock1  \n")
            lock1.release()
        else:
            print("Task 2 could not acquire lock1  \n")

t1 = threading.Thread(target=task1)
t2 = threading.Thread(target=task2)

t1.start()
t2.start()

t1.join()
t2.join()

print("Execution Completed")

# Avoiding Deadlock (using lock order)

import threading
import time

lock1 = threading.Lock()
lock2 = threading.Lock()

def task1():
    with lock1:
        print("Task 1 acquired lock1 \n")
        time.sleep(1)
        if lock2.acquire(timeout=2):
            print("Task 1 acquired lock2 \n")
            lock2.release()
        else:
            print("Task 1 could not acquire lock2  \n")

def task2():
    with lock2:
        print("Task 2 acquired lock2  \n")
        time.sleep(1)
        if lock1.acquire(timeout=2):
            print("Task 2 acquired lock1  \n")
            lock1.release()
        else:
            print("Task 2 could not acquire lock1  \n")

t1 = threading.Thread(target=task1)
t1.start()
t1.join()

t2 = threading.Thread(target=task2)
t2.start()
t2.join()

print("Execution Completed")
