# Polymorphism 
class Dog:
    def speak(self):
        print("Dog sound - Woof !")

class Cat:
    def speak(self):
        print("Cat sound - Meow !")

def anmlsound(animal):
    animal.speak()

d = Dog()
c = Cat()
anmlsound(d)
anmlsound(c)

# Duck Typing
class Bird:
    def fly(self):
        print("Bird is flying")

class Airplane:
    def fly(self):
        print("Airplane is flying")

def flying(obj):
    obj.fly()

b = Bird()
a = Airplane()
flying(b)
flying(a)

# Operator Overloading
class Point:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def __add__(self, other):
        x = self.x + other.x
        y = self.y + other.y
        return Point(x,y)

p1 = Point(1,2)
p2 = Point(2,3)

p3 = p1 + p2

print((p3.x, p3.y))

# Method Overloading
#Example using default arguments:
class MathOperations:
    def add(self, a, b, c=0, d=0):
        return a + b + c + d

math_op = MathOperations()

print(math_op.add(2, 3))
print(math_op.add(2, 3, 4))
print(math_op.add(2, 3, 4, 5))

#Example using variable-length arguments:
class MathOperations:
    def add(self, *args):
        return sum(args)

math_op = MathOperations()

print(math_op.add(2, 3))
print(math_op.add(2, 3, 4))
print(math_op.add(2, 3, 4, 5))

#Example using variable-length keyword arguments:
class MathOperations:
    def add(self, **kwargs):
        a = kwargs.get('a', 0)
        b = kwargs.get('b', 0)
        c = kwargs.get('c', 0)
        d = kwargs.get('d', 0)
        return a + b + c+ d
    
math_op = MathOperations()
print(math_op.add(a=2, b=3))
print(math_op.add(a=2, b=3, c=4))
print(math_op.add(a=2, b=3, c=4, d=5))

# Method Overriding
class Animal:
    def make_sound(self):
        return "Some generic sound"

class Dog(Animal):
    def make_sound(self):
        return "Woof!"

class Cat(Animal):
    def make_sound(self):
        return "Meow!"

dog = Dog()
cat = Cat()

print(dog.make_sound())
print(cat.make_sound())


